#version 430

// Work group size
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// Input and output textures
layout(binding = 0, rgba16f) uniform readonly image2D inputTexture;
layout(binding = 1, rgba8) uniform writeonly image2D outputTexture;

// Uniforms
uniform float exposure = 1.0;
uniform float gamma = 2.2;
uniform int toneMappingMode = 0; // 0: Reinhard, 1: ACES, 2: Uncharted2
uniform float whitePoint = 11.2;

// Reinhard tone mapping
vec3 reinhardToneMapping(vec3 color) {
    return color / (color + vec3(1.0));
}

// ACES tone mapping (approximation)
vec3 acesToneMapping(vec3 color) {
    const float a = 2.51;
    const float b = 0.03;
    const float c = 2.43;
    const float d = 0.59;
    const float e = 0.14;
    
    return clamp((color * (a * color + b)) / (color * (c * color + d) + e), 0.0, 1.0);
}

// Uncharted 2 tone mapping
vec3 uncharted2Partial(vec3 x) {
    const float A = 0.15;
    const float B = 0.50;
    const float C = 0.10;
    const float D = 0.20;
    const float E = 0.02;
    const float F = 0.30;
    
    return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;
}

vec3 uncharted2ToneMapping(vec3 color) {
    vec3 curr = uncharted2Partial(color * 2.0);
    vec3 whiteScale = 1.0 / uncharted2Partial(vec3(whitePoint));
    return curr * whiteScale;
}

// Gamma correction
vec3 gammaCorrection(vec3 color, float gamma) {
    return pow(color, vec3(1.0 / gamma));
}

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 outputSize = imageSize(outputTexture);
    
    if (coord.x >= outputSize.x || coord.y >= outputSize.y) {
        return;
    }
    
    // Sample input color
    vec3 hdrColor = imageLoad(inputTexture, coord).rgb;
    
    // Apply exposure
    hdrColor *= exposure;
    
    // Apply tone mapping
    vec3 ldrColor;
    if (toneMappingMode == 0) {
        ldrColor = reinhardToneMapping(hdrColor);
    } else if (toneMappingMode == 1) {
        ldrColor = acesToneMapping(hdrColor);
    } else if (toneMappingMode == 2) {
        ldrColor = uncharted2ToneMapping(hdrColor);
    } else {
        // Default to Reinhard
        ldrColor = reinhardToneMapping(hdrColor);
    }
    
    // Apply gamma correction
    ldrColor = gammaCorrection(ldrColor, gamma);
    
    // Clamp to [0, 1] range
    ldrColor = clamp(ldrColor, 0.0, 1.0);
    
    // Write result
    imageStore(outputTexture, coord, vec4(ldrColor, 1.0));
}